---
title: "EpiCompare Report"
date: "`r format(Sys.Date(), '%b-%d-%Y')`"
output: 
  html_document: 
    toc: yes
    toc_float: yes
params:
  peakfile: 
    value: NULL
  output_dir: 
    value: NULL
  blacklist: 
    value: NULL
  picard_files:
    value : NULL
  reference: 
    value: NULL
  upset_plot:
    value: FALSE
  stat_plot:
    value: FALSE
  chrmHMM_plot:
    value: FALSE
  chrmHMM_annotation:
    value: "K562"
  chipseeker_plot:
    value: FALSE
  enrichment_plot:
    value: FALSE
  interact:
    value: TRUE
  save_output:
    value: FALSE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
# if save_output is TRUE, create a directory to save all outputs, if it doesn't exist already 
if(params$save_output){
  outfile_dir <- paste0(params$output_dir,"/EpiCompare_file")
  if(!dir.exists(outfile_dir)){
    dir.create(outfile_dir)
  }
}
# prepare a list of GRange object
# and check that the list is named, if not default filenames are used 
peaklist <- prepare_peaklist(params$peakfile)
# tidy input peakfiles to remove peaks in blacklisted regions and non-standard chromosomes 
peaklist_tidy <- tidy_peakfile(peaklist = peaklist,
                               blacklist = params$blacklist)
# tidy input reference peakfile if provided
if (is.null(params$reference) == FALSE){
  reference_tidy <- tidy_peakfile(peaklist = params$reference,
                                  blacklist = params$blacklist)
  peaklist_tidy <- c(peaklist_tidy, reference_tidy)
}
# adjust figure height depending on sample size  
fig_height <- 7
if(length(peaklist_tidy)>10){
  extra_n <- length(peaklist_tidy) - 10
  extra_height <- extra_n*0.25
  fig_height <- fig_height + extra_height 
}
```

[EpiCompare](https://github.com/neurogenomics/EpiCompare) compares different epigenetic datasets for quality control and benchmarking purposes. 
The report is divided into three sections: 

1. **General Metrics:** Metrics on fragments (duplication rate) and peaks (blacklisted peaks and peak widths) of input files
2. **Peak Overlap:** Percentage and statistical significance of overlapping and non-overlapping peaks.
3. **Functional Annotation:** Functional annotation (ChromHMM, ChIPseeker and enrichment analysis) of peaks. 

***

##### Input Datasets 

* Reference peakfile: `r names(reference_tidy)`
* Total of `r length(peaklist_tidy)` peak files: 

```{r name, echo=FALSE}
# print peak file names and numerate 
n <- 1
for (name in names(peaklist_tidy)){
  print(paste0("File", n, ": ", name))
  n <- n + 1
}
```

##### Code

<details>

```R
EpiCompare(peakfiles = list(`r names(peaklist_tidy)`),
           blacklist = blacklist,
           picard_files = list(`r names(params$picard_files)`),
           reference = `r names(reference_tidy)`,
           stat_plot = `r params$stat_plot`,
           chrmHMM_plot = `r params$chrmHMM_plot`,
           chrmHMM_annotation = "`r params$chrmHMM_annotation`",
           chipseeker_plot = `r params$chipseeker_plot`,
           enrichment_plot = `r params$enrichment_plot`,
           interact = `r params$interact`,
           save_output = `r params$save_output`,
           output_dir = "`r params$output_dir`")
```

</details>


***

## 1. General Metrics {.tabset}

### Peak Information 

Column Description:

* PeakN before tidy: Total number of peaks including those blacklisted and those in non-standard chromosomes. 
* Blacklisted peaks removed (%): Percentage of blacklisted peaks present in the sample. [ENCODE blacklist](https://www.encodeproject.org/files/ENCFF000KJP/) includes regions in the hg19 genome that have 
anomalous and/or unstructured signals independent of the cell-line or experiment.
* Non-standard peaks removed (%): Percentage of peaks identified in non-standard and/or mitochondrial chromosomes.
Identified using `BRGenomics::tidyChromosomes()`.  
* PeakN after tidy: Total number of peaks after filtering blacklisted peaks and those in non-standard chromosomes. 

  NB: All analyses in EpiCompare are conducted on *tidied* datasets (i.e. blacklisted peaks and those in non-standard chromosomes removed)

<br>

```{r, echo=FALSE, warning=FALSE}
peak_info_df <- peak_info(peak_list = peaklist,
                          blacklist = params$blacklist)
# create table 
knitr::kable(peak_info_df, format = "markdown")
# save output as table 
if(params$save_output){
  write.table(peak_info_df, file=paste0(outfile_dir,"/peak_info"), sep="\t")
}
```

***

### Fragment Information

Metrics on fragments is shown only if Picard summary is provided. See [manual](https://neurogenomics.github.io/EpiCompare/) for help. 

Column Description:

* Mapped_Fragments: Number of mapped read pairs in the file. 
* Duplication_Rate: Percentage of mapped sequence that is marked as duplicate.
* Unique_Fragments: Number of mapped sequence that is not marked as duplicate. 

<br>

```{r, echo=FALSE, warning=FALSE, results='asis'}
# only if picard_files is provided, run the function 
if (!is.null(params$picard_files)){
  fragment_info_df <- fragment_info(picard_list = params$picard_files)
  # output data frame 
  print(knitr::kable(fragment_info_df, format = "markdown"))
  # save output 
  if(params$save_output){
    write.table(fragment_info_df, file=paste0(outfile_dir,"/fragment_info"), sep="\t")
  }
}   
```

***

### Peak widths 

Distribution of peak widths in each sample. 

<br> 

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.width=10, fig.height= fig_height}
# create boxplot of peak widths 
width_plot <- width_boxplot(peaklist = peaklist_tidy)
print(width_plot)
# save boxplot output 
if(params$save_output){
  ggplot2::ggsave(filename = "width_plot.png",plot = width_plot, device = "png", path = outfile_dir)
  unlink("width_plot.png")
}
```

***

## 2. Peak Overlap {.tabset}

### Percentage Overlap  

Heatmap of percentage of overlapping peaks between samples. 
Hover over the heatmap for percentage values. 

N.B. How to interpret heatmap: [Samples in x-axis of heatmap] peaks in [Samples in y-axis of heatmap] peaks 

<br>

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.width=10, fig.height=fig_height}
overlap_heatmap <- overlap_heatmap(peaklist = peaklist_tidy,
                                   interact = params$interact)
overlap_heatmap
# save output 
if(params$save_output){
  if(params$interact){
    htmlwidgets::saveWidget(plotly::as_widget(overlap_heatmap), file = paste0(outfile_dir,"/samples_percent_overlap.html"))
    unlink(paste0(outfile_dir,"/samples_percent_overlap_files"), recursive = TRUE)
  }else{
    ggplot2::ggsave(filename = "samples_percent_overlap.png", plot = overlap_heatmap, device = "png", path = outfile_dir)
    unlink("samples_percent_overlap.png")
    }
}
```

***

### Upset Plot 

Upset plot of overlapping peaks between samples. 
See [here](https://jokergoo.github.io/ComplexHeatmap-reference/book/upset-plot.html) on how to interpret upset plots.   

```{r, echo=FALSE, fig.width=10, fig.height = fig_height, warning=FALSE, message=FALSE, results='asis'}
if(params$upset_plot){
  upset_plot <- overlap_upset_plot(peaklist = peaklist_tidy)
  print(upset_plot)
  # save output 
  if(params$save_output){
    png(paste0(outfile_dir,"/upset_plot.png"))
    print(upset_plot)
    dev.off()
  }
}

```

***

### Statistical Significance  

The plot is shown only if a reference peak file is provided and `stat_plot = TRUE`. 
Depending on the format of the reference file, EpiCompare outputs different plots: 

* Reference dataset has BED6+4 format (peakcalling performed with MACS2): EpiCompare generates paired boxplot 
per sample showing the distribution of -log10(q-value) of reference peaks that are overlapping and non-overlapping with the sample dataset. 
* Reference dataset does not have BED6+4 format: EpiCompare generates a barplot of percentage of overlapping sample peaks with the reference, coloured by statistical significance (adjusted p-value) of the overlap. 

Keys:

**Reference peakfile: `r names(reference_tidy)`**

* Overlap: Sample peaks in Reference peaks 
* Unique: Sample peaks not in Reference peaks  

<br>

```{r, echo=FALSE, fig.width=10, warning=FALSE, message=FALSE, fig.height= fig_height}
# if reference is provided AND stat_plot=TRUE, run the function 
if (is.null(params$reference) == FALSE){
  if (params$stat_plot){
    stat_plot <- overlap_stat_plot(reference = reference_tidy,
                                   peaklist = peaklist_tidy)
    print(stat_plot[[1]])
    # save output 
    if(params$save_output){
      ggplot2::ggsave(filename = "stat_plot.png", plot = stat_plot[[1]], device = "png", path = outfile_dir)
      unlink("stat_plot.png")
      }
  }
}
```

***

## 3. Functional Annotation 

### 3.1 ChromHMM {.tabset}

[ChromHMM](http://compbio.mit.edu/ChromHMM/#:~:text=ChromHMM%20is%20software%20for%20learning%20and%20characterizing%20chromatin%20states.&text=ChromHMM%20is%20based%20on%20a,one%20or%20more%20cell%20types.) annotates and characterises peaks into different chromatin states. ChromHMM annotations used in EpiCompare were obtained from [here](http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeBroadHmm/).

* Cell-type annotation file used in this analysis: `r params$chrmHMM_annotation`

#### All samples 

ChromHMM annotation of individual samples. 

```{r, echo=FALSE, fig.width=9, warning=FALSE, message=FALSE, results='asis', fig.height=fig_height}
# if chrmHMM_plot=TRUE, create ChromHMM heatmaps 
if (params$chrmHMM_plot){
  # user-specified ChromHMM annotation file 
  chrHMM_list <- get_chrHMM_annotation(cell_line = params$chrmHMM_annotation)
  # plot chromHMM
  samples_chrmHMM <- plot_chrmHMM(peaklist = peaklist_tidy, chrmHMM_annotation = chrHMM_list, interact = params$interact)
  # save output 
  if(params$save_output){
    if(params$interact){
      htmlwidgets::saveWidget(plotly::as_widget(samples_chrmHMM), file = paste0(outfile_dir,"/samples_chromHMM.html"))
      unlink(paste0(outfile_dir,"/samples_chromHMM_files"), recursive = TRUE)
    }else{
      ggplot2::ggsave(filename = "samples_chromHMM.png", plot = samples_chrmHMM, device = "png", path = outfile_dir)
      unlink("samples_chromHMM.png")
    }
  }
}else{
  samples_chrmHMM <- "No plot"
}
samples_chrmHMM
```

#### **Overlap**: Sample peaks in Reference peaks 

Percentage of Sample peaks found in Reference peaks (**Reference peakfile: `r names(reference_tidy)`**)

```{r, echo=FALSE, fig.width=9, warning=FALSE, message=FALSE, results='asis'}
if (params$chrmHMM_plot){
  if (is.null(params$reference)==FALSE){
    # table of percentage overlap
    sample_in_ref_df <- overlap_percent(peaklist = peaklist_tidy,
                                        reference = reference_tidy[[1]],
                                        invert = FALSE)
    knitr::kable(sample_in_ref_df, format = "markdown")
  }
}
```

ChromHMM annotation of sample peaks found in reference peaks.   

```{r, echo=FALSE, fig.width=9, warning=FALSE, message=FALSE, results='asis', fig.height=fig_height}
if (params$chrmHMM_plot){
  if (is.null(params$reference)==FALSE){
    # obtain overlapping peaks 
    sample_in_ref_list <- list()
    for(file in peaklist_tidy){
      sample_in_ref <- IRanges::subsetByOverlaps(x = file, ranges = reference_tidy[[1]])
      sample_in_ref_list <- c(sample_in_ref_list, sample_in_ref)
    }
    names(sample_in_ref_list) <- names(peaklist_tidy)
    # annotate overlapping peaks with chromHMM annotations
    sample_in_ref_chrmHMM <- plot_chrmHMM(peaklist = sample_in_ref_list,
                                          chrmHMM_annotation = chrHMM_list,
                                          interact = params$interact)
    # save output 
    if(params$save_output){
      if(params$interact){
        htmlwidgets::saveWidget(plotly::as_widget(sample_in_ref_chrmHMM), file = paste0(outfile_dir,"/sample_in_ref_chromHMM.html"))
        unlink(paste0(outfile_dir,"/sample_in_ref_chromHMM_files"), recursive = TRUE)
      }else{
        ggplot2::ggsave(filename = "sample_in_ref_chromHMM.png", plot = sample_in_ref_chrmHMM, device = "png", path = outfile_dir)
        unlink("sample_in_ref_chromHMM.png")
      }
    }
  }
}else{
  sample_in_ref_chrmHMM <- "No plot"
}
sample_in_ref_chrmHMM

```

#### **Overlap**: Reference peaks in Sample peaks 

Percentage of Reference peaks found in Sample peaks (**Reference peakfile: `r names(reference_tidy)`**)

```{r, echo=FALSE, fig.width=9, warning=FALSE, message=FALSE, results='asis'}
if (params$chrmHMM_plot){
  if (is.null(params$reference)==FALSE){
    # table of percentage overlap
    ref_in_sample_df <- overlap_percent(peaklist = reference_tidy[[1]],
                                        reference = peaklist_tidy,
                                        invert = FALSE)
    knitr::kable(ref_in_sample_df, format = "markdown")
    
  }
}
```

ChromHMM annotation of reference peaks found in sample peaks.   

```{r, echo=FALSE, fig.width=9, warning=FALSE, message=FALSE, results='asis', fig.height=fig_height}
if (params$chrmHMM_plot){
  if (is.null(params$reference)==FALSE){
    ref_in_sample_list <- list()
    # obtain overlapping peaks 
    for(file in peaklist_tidy){
      ref_in_sample <- IRanges::subsetByOverlaps(x = reference_tidy[[1]], ranges = file)
      ref_in_sample_list <- c(ref_in_sample_list, ref_in_sample)
    }
    names(ref_in_sample_list) <- names(peaklist_tidy)
    # annotate overlapping peaks with chromHMM annotations
    ref_in_sample_chrmHMM <- plot_chrmHMM(peaklist = ref_in_sample_list,
                                          chrmHMM_annotation = chrHMM_list,
                                          interact = params$interact)
    # save output 
    if(params$save_output){
      if(params$interact){
        htmlwidgets::saveWidget(plotly::as_widget(ref_in_sample_chrmHMM), file = paste0(outfile_dir,"/ref_in_sample_chrmHMM.html"))
        unlink(paste0(outfile_dir,"/ref_in_sample_chrmHMM_files"), recursive = TRUE)
      }else{
        ggplot2::ggsave(filename = "ref_in_sample_chromHMM.png", plot = ref_in_sample_chrmHMM, device = "png", path = outfile_dir)
        unlink("ref_in_sample_chromHMM.png")
      }
    }
  }
}else{
  ref_in_sample_chrmHMM <- "No plot"
}
ref_in_sample_chrmHMM
```

#### **Unique**: Sample peaks not in Reference peaks 

Percentage of sample peaks not found in reference peaks (**Reference peakfile: `r names(reference_tidy)`**)

```{r, echo=FALSE, fig.width=9, warning=FALSE, message=FALSE, results='asis'}
if (params$chrmHMM_plot){
  if (is.null(params$reference)==FALSE){
    # table of percentage overlap
    sample_not_in_ref_df <- overlap_percent(peaklist = peaklist_tidy,
                                            reference = reference_tidy[[1]],
                                            invert = TRUE)
    knitr::kable(sample_not_in_ref_df, format = "markdown")
  }
}
```

ChromHMM annotation of sample peaks not found in reference peaks. 

```{r, echo=FALSE, fig.width=9, warning=FALSE, message=FALSE, results='asis', fig.height=fig_height}
if (params$chrmHMM_plot){
  if (is.null(params$reference)==FALSE){
      sample_not_in_ref_list <- list()
      # obtain unique peaks 
      for(file in peaklist_tidy){
        sample_not_in_ref <- IRanges::subsetByOverlaps(x = file, ranges = reference_tidy[[1]], invert = TRUE)
        sample_not_in_ref_list <- c(sample_not_in_ref_list, sample_not_in_ref)
      }
      names(sample_not_in_ref_list) <- names(peaklist_tidy)
      # annotate unique peaks with chromHMM annotations
      sample_not_in_ref_chrmHMM <- plot_chrmHMM(peaklist = sample_not_in_ref_list,
                                                chrmHMM_annotation = chrHMM_list,
                                                interact = params$interact)
      # save output 
      if(params$save_output){
        if(params$interact){
          htmlwidgets::saveWidget(plotly::as_widget(ref_in_sample_chrmHMM), file = paste0(outfile_dir,"/ref_in_sample_chrmHMM.html"))
          unlink(paste0(outfile_dir,"/ref_in_sample_chrmHMM_files"), recursive = TRUE)

        }else{
          ggplot2::ggsave(filename = "sample_not_in_ref_chromHMM.png", plot = sample_not_in_ref_chrmHMM, device = "png", path = outfile_dir)
          unlink("sample_not_in_ref_chromHMM.png")
          }
      }
  }
}else{
  sample_not_in_ref_chrmHMM <- "No plot"
}
sample_not_in_ref_chrmHMM

```

#### **Unique**: Reference peaks not in Sample peaks 

Percentage of reference peaks not found in sample peaks (**Reference peakfile: `r names(reference_tidy)`**)

```{r, echo=FALSE, fig.width=9, warning=FALSE, message=FALSE, results='asis'}
if (params$chrmHMM_plot){
  if (is.null(params$reference)==FALSE){
    # table of percentage overlap
    ref_not_in_sample_df <- overlap_percent(peaklist = reference_tidy[[1]],
                                        reference = peaklist_tidy,
                                        invert = TRUE)
    knitr::kable(ref_not_in_sample_df, format = "markdown")
  }
}
```

ChromHMM annotation of reference peaks not found in sample peaks. 

```{r, echo=FALSE, fig.width=9, warning=FALSE, message=FALSE, results='asis', fig.height=fig_height}
if (params$chrmHMM_plot){
  if (is.null(params$reference)==FALSE){
      ref_not_in_sample_list <- list()
      # obtain unique peaks 
      for(file in peaklist_tidy){
        ref_not_in_sample <- IRanges::subsetByOverlaps(x = reference_tidy[[1]], ranges = file, invert = TRUE)
        ref_not_in_sample_list <- c(ref_not_in_sample_list, ref_not_in_sample)
      }
      names(ref_not_in_sample_list) <- names(peaklist_tidy)
      # annotate unique peaks with chromHMM annotations
      ref_not_in_sample_chrmHMM <- plot_chrmHMM(peaklist = ref_not_in_sample_list,
                                                chrmHMM_annotation = chrHMM_list,
                                                interact = params$interact)
      # save output 
      if(params$save_output){
        if(params$interact){
          htmlwidgets::saveWidget(plotly::as_widget(ref_not_in_sample_chrmHMM), file = paste0(outfile_dir,"/ref_not_in_sample_chrmHMM.html"))
          unlink(paste0(outfile_dir,"/ref_not_in_sample_chrmHMM_files"), recursive = TRUE)
        }else{
          ggplot2::ggsave(filename = "ref_not_in_sample_chromHMM.png", plot = ref_not_in_sample_chrmHMM, device = "png", path = outfile_dir)
          unlink("ref_not_in_sample_chromHMM.png")
        }
      }
  }
}else{
  ref_not_in_sample_chrmHMM <- "No plot"
}
ref_not_in_sample_chrmHMM
```

### 3.2 ChIPseeker 

EpiCompare uses `annotatePeak` function in `ChIPseeker` package to annotate peaks with the nearest gene and 
genomic region where the peak is located. The peaks are annotated with [genes](http://bioconductor.org/packages/release/data/annotation/html/TxDb.Hsapiens.UCSC.hg19.knownGene.html) taken from the annotations of human genome hg19 provided by Bioconductor.

```{r, echo=FALSE, fig.width=9, warning=FALSE, message=FALSE}
# if set TRUE, generate chipseeker annotation plot 
if (params$chipseeker_plot){
  chipseeker_plot <- plot_ChIPseeker_annotation(peaklist = peaklist_tidy)
  print(chipseeker_plot)
  # save output 
  if(params$save_output){
    ggplot2::ggsave(filename = "chipseeker_annotation.png", plot = chipseeker_plot, device = "png", path = outfile_dir)
    unlink("chipseeker_annotation.png")
    }
}
```

### 3.3 Functional Enrichment Analysis {.tabset}

EpiCompare performs KEGG pathway and GO enrichment analysis using `clusterProfiler`. 
`annotatePeak` function in `ChIPseeker` package is first used to assign peaks to nearest genes 
and biological themes amongst the genes are identified using ontologies (KEGG and GO).
The peaks are annotated with [genes](http://bioconductor.org/packages/release/data/annotation/html/TxDb.Hsapiens.UCSC.hg19.knownGene.html) taken from the annotations of human genome hg19 provided by Bioconductor.


```{r, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}
fig_height <- 10
if (params$enrichment_plot){
  enrichment_plots <- plot_enrichment(peaklist = peaklist_tidy)
  KEGG_plot <- enrichment_plots[[1]]
  GO_plot <- enrichment_plots[[2]]
  kegg_terms <- length(unique(KEGG_plot$data$Description))
  go_terms <- length(unique(GO_plot$data$Description))
  if(kegg_terms > 20 | go_terms > 20){
    maxN <- max(kegg_terms, go_terms)
    extraN <- maxN - 20
    fig_height <- fig_height + extraN*0.25
  }
}
```

#### KEGG

```{r, echo=FALSE, fig.width= 10, fig.height = fig_height, warning=FALSE, message=FALSE}
if (params$enrichment_plot){
  print(KEGG_plot)
  # save output 
  if(params$save_output){
    ggplot2::ggsave(filename = "KEGG_analysis.png", plot = KEGG_plot, device = "png", path = outfile_dir)
    unlink("KEGG_analysis.png")
  }
}
```

#### GO 

```{r, echo=FALSE, fig.width=10,fig.height = fig_height, warning=FALSE, message=FALSE}
if (params$enrichment_plot){
  print(GO_plot)
  # save output 
  if(params$save_output){
    ggplot2::ggsave(filename = "GO_analysis.png", plot = GO_plot, device = "png", path = outfile_dir)
    unlink("GO_analysis.png")
  }
}

```

### 4. Session Info

<details> 

```{r Session Info}
utils::sessionInfo()
```

</details>  

