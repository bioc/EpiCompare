---
title: "EpiCompare Report"
date: "`r format(Sys.Date(), '%b-%d-%Y')`"
output: 
  html_document: 
    toc: yes
    toc_float: yes
params:
  peakfile: 
    value: NULL
  output_dir: 
    value: NULL
  genome_build:
    value: NULL
  genome_build_output:
    value: "hg19"
  blacklist: 
    value: NULL
  picard_files:
    value : NULL
  reference: 
    value: NULL
  upset_plot:
    value: FALSE
  stat_plot:
    value: FALSE
  chromHMM_plot:
    value: FALSE
  chromHMM_annotation:
    value: "K562"
  chipseeker_plot:
    value: FALSE
  enrichment_plot:
    value: FALSE
  tss_plot:
    value: FALSE
  interact:
    value: TRUE
  save_output:
    value: FALSE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
# if save_output is TRUE, create a directory to save all outputs,
# if it doesn't exist already 
if(params$save_output){
  outfile_dir <- paste0(params$output_dir,"/EpiCompare_file")
  if(!dir.exists(outfile_dir)){
    dir.create(outfile_dir, showWarnings = FALSE, recursive = TRUE)
  }
}

#### ------ Prepare genome builds ------ ####
# e.g. genome_build <- list(reference="hg19",peakfiles="hg38",blacklist="hg19")
# or... genome_build <- "hg19"
builds <- prepare_genome_builds(genome_build = params$genome_build)
## Standardise all data to hg19 build 
output_build <- prepare_output_build(params$genome_build_output)

#### ------ Prepare peaklist(s) ------ ####
# and check that the list is named, if not default filenames are used 
peaklist <- prepare_peaklist(peaklist = params$peakfile) 
peaklist <- liftover_grlist(grlist = peaklist, 
                            input_build = builds$peaklist,
                            output_build = output_build)

#### ------ Prepare reference(s) ------ ####
reference <- prepare_reference(reference = params$reference)
reference <- liftover_grlist(grlist = reference, 
                            input_build = builds$reference,
                            output_build = output_build)

#### ------ Prepare blacklist ------ ####
blacklist <- liftover_grlist(grlist = params$blacklist,
                             input_build = builds$blacklist, 
                             output_build = output_build) 

### Standardise peaklist(s) ###
peaklist_tidy <- tidy_peakfile(peaklist = peaklist,
                               blacklist = blacklist)

### Standardise reference(s) ###
# and include in peaklist
reference_tidy <- reference
if (!is.null(reference)){
  reference_tidy <- tidy_peakfile(peaklist = reference,
                                  blacklist = blacklist)
  peaklist_tidy <- c(peaklist_tidy, reference_tidy)
}

### Obtain Genome Annotation ### 
txdb <- check_genome_build(genome_build = output_build)

### Dynamic Figure Height ###  
fig_height <- 7
if(length(peaklist_tidy)>10){
  extra_n <- length(peaklist_tidy) - 10
  extra_height <- extra_n*0.25
  fig_height <- fig_height + extra_height 
}
```

[EpiCompare](https://github.com/neurogenomics/EpiCompare) compares epigenetic 
datasets for quality control and benchmarking purposes. 
The report consists of three sections: 

1. **General Metrics:** Metrics on peaks (percentage of blacklisted and 
non-standard peaks, and peak widths) 
and fragments (duplication rate) of samples.
2. **Peak Overlap:** Percentage and statistical significance of overlapping and 
non-overlapping peaks. Also includes upset plot. 
3. **Functional Annotation:** Functional annotation (ChromHMM, ChIPseeker and 
enrichment analysis) of peaks. Also includes peak enrichment around TSS. 

***

##### Input Datasets 

* Reference peakfile: `r names(reference_tidy)`
* Total of `r length(peaklist_tidy)` peak files: 

```{r name, echo=FALSE}
# print peak file names and numerate 
n <- 1
for (name in names(peaklist_tidy)){
  print(paste0("File", n, ": ", name))
  n <- n + 1
}
```

##### Code

<details>

```R
EpiCompare(peakfiles = list(`r names(peaklist_tidy)`),
           genome_build = `r params$genome_build`,
           genome_build_output = `r params$genome_build_output`,
           blacklist = blacklist,
           picard_files = list(`r names(params$picard_files)`),
           reference = `r names(reference_tidy)`,
           upset_plot = `r params$upset_plot`,
           stat_plot = `r params$stat_plot`,
           chromHMM_plot = `r params$chromHMM_plot`,
           chromHMM_annotation = "`r params$chromHMM_annotation`",
           chipseeker_plot = `r params$chipseeker_plot`,
           enrichment_plot = `r params$enrichment_plot`,
           tss_plot = `r params$tss_plot`,
           interact = `r params$interact`,
           save_output = `r params$save_output`,
           output_dir = "`r params$output_dir`")
```

</details>


***

## 1. General Metrics {.tabset}

### Peak Information 

Column Description:

* PeakN before tidy: Total number of peaks including those blacklisted and those 
in non-standard chromosomes. 
* Blacklisted peaks removed (%): Percentage of blacklisted peaks in samples. 
E.g. [ENCODE hg19 blacklist](https://www.encodeproject.org/files/ENCFF000KJP/) 
includes regions in the hg19 genome that have anomalous and/or unstructured 
signals independent of the cell-line or experiment.
* Non-standard peaks removed (%): Percentage of peaks in non-standard and/or 
mitochondrial chromosomes.
Identified using `BRGenomics::tidyChromosomes()`.  
* PeakN after tidy: Total number of peaks after removing those in blacklisted 
regions and non-standard chromosomes. 

**NB**: EpiCompare uses *filtered* peakfiles (i.e. datasets after removing peaks
in blacklisted regions and non-standard chromosomes)

<br>

```{r, echo=FALSE, warning=FALSE}

peak_info_df <- peak_info(peaklist = peaklist,
                          blacklist = blacklist)
# create table 
knitr::kable(peak_info_df, format = "markdown")
# save output as table 
if(params$save_output){
  data.table::fwrite(x = peak_info_df, file=paste0(outfile_dir,"/peak_info"),
                     sep="\t")
}
```

***

### Fragment Information

Metrics on fragments is shown only if Picard summary is provided. 
See [manual](https://neurogenomics.github.io/EpiCompare/) for help. 

Column Description:

* Mapped_Fragments: Number of mapped read pairs in the file. 
* Duplication_Rate: Percentage of mapped sequence that is marked as duplicate.
* Unique_Fragments: Number of mapped sequence that is not marked as duplicate. 

<br>

```{r, echo=FALSE, warning=FALSE, results='asis'}
# only if picard_files is provided, run the function 
if (!is.null(params$picard_files)){
  fragment_info_df <- fragment_info(picard_list = params$picard_files)
  # output data frame 
  print(knitr::kable(fragment_info_df, format = "markdown"))
  # save output 
  if(params$save_output){
    data.table::fwrite(x = fragment_info_df,
                       file=paste0(outfile_dir,"/fragment_info"), 
                       sep="\t")
  }
}   
```

***

### Peak widths 

Distribution of peak widths in samples 

<br> 

```{r,echo=FALSE,warning=FALSE,message=FALSE,fig.width=10,fig.height=fig_height}
# create boxplot of peak widths 
width_plot <- width_boxplot(peaklist = peaklist_tidy)
print(width_plot)
# save boxplot output 
if(params$save_output){
  ggplot2::ggsave(filename = "width_plot.png",plot = width_plot, device = "png", 
                  path = outfile_dir)
  unlink("width_plot.png")
}
```

***

## 2. Peak Overlap {.tabset}

### Percentage Overlap  

Percentage of overlapping peaks between samples. 
Hover over heatmap for percentage values. 

N.B. How to interpret heatmap: [Samples in x-axis of heatmap] peaks in 
[Samples in y-axis of heatmap] peaks 

<br>

```{r,echo=FALSE,warning=FALSE,message=FALSE,fig.width=10,fig.height=fig_height}
overlap_heatmap <- overlap_heatmap(peaklist = peaklist_tidy,
                                   interact = params$interact)
overlap_heatmap
# save output 
if(params$save_output){
  if(params$interact){
    htmlwidgets::saveWidget(plotly::as_widget(overlap_heatmap), 
                            file = paste0(outfile_dir,
                                          "/samples_percent_overlap.html"))
    unlink(paste0(outfile_dir,"/samples_percent_overlap_files"), 
           recursive = TRUE)
  }else{
    ggplot2::ggsave(filename = "samples_percent_overlap.png",
                    plot = overlap_heatmap, device = "png", path = outfile_dir)
    unlink("samples_percent_overlap.png")
  }
}
```

***

### Upset Plot 

Upset plot of overlapping peaks between samples. See 
[here](https://jokergoo.github.io/ComplexHeatmap-reference/book/upset-plot.html)
on how to interpret the plot.   

```{r, echo=FALSE,fig.width=10,fig.height=fig_height,warning=FALSE,message=FALSE,results='asis'}
if(params$upset_plot){
  upset_plot <- overlap_upset_plot(peaklist = peaklist_tidy)
  print(upset_plot)
  # save output 
  if(params$save_output){
    png(paste0(outfile_dir,"/upset_plot.png"))
    print(upset_plot)
    dev.off()
  }
}

```

***

### Statistical Significance  

Depending on the format of the reference file, EpiCompare outputs different 
plots: 

* Reference dataset has BED6+4 format (peakcalling performed with MACS2): 
EpiCompare generates paired boxplot 
per sample showing the distribution of -log10(q-value) of reference peaks that 
are overlapping and non-overlapping with the sample dataset. 
* Reference dataset does not have BED6+4 format: EpiCompare generates a barplot 
of percentage of overlapping sample peaks with the reference, coloured by 
statistical significance (adjusted p-value) of the overlap. 

**Reference peakfile: `r names(reference_tidy)`**

Keys:

* Overlap: Sample peaks in Reference peaks 
* Unique: Sample peaks not in Reference peaks  

<br>

```{r,echo=FALSE,fig.width=10,warning=FALSE,message=FALSE,fig.height=fig_height}
# if reference is provided AND stat_plot=TRUE, run the function 
if (is.null(reference) == FALSE){
  if (params$stat_plot){
    stat_plot <- overlap_stat_plot(reference = reference_tidy,
                                   peaklist = peaklist_tidy,
                                   annotation = txdb)
    print(stat_plot[[1]])
    # save output 
    if(params$save_output){
      ggplot2::ggsave(filename = "stat_plot.png", plot = stat_plot[[1]], 
                      device = "png", path = outfile_dir)
      unlink("stat_plot.png")
      }
  }
}
```

***

## 3. Functional Annotation 

### 3.1 ChromHMM {.tabset}

[ChromHMM](http://compbio.mit.edu/ChromHMM/#:~:text=ChromHMM%20is%20software%20for%20learning%20and%20characterizing%20chromatin%20states.&text=ChromHMM%20is%20based%20on%20a,one%20or%20more%20cell%20types.) 
annotates and characterises peaks into different chromatin states. ChromHMM 
annotations used in EpiCompare were obtained from
[here](http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeBroadHmm/).

* Cell-type annotation file used in this analysis: `r params$chromHMM_annotation`

#### All samples 

ChromHMM annotation of individual samples. 

```{r, echo=FALSE, fig.width=9, warning=FALSE, message=FALSE, results='asis', fig.height=fig_height}
# if chromHMM_plot=TRUE, create ChromHMM heatmaps 
if (params$chromHMM_plot){
  # user-specified ChromHMM annotation file 
  chromHMM_list <- get_chromHMM_annotation(cell_line = params$chromHMM_annotation)
  # plot chromHMM
  samples_chromHMM <- plot_chromHMM(peaklist = peaklist_tidy, 
                                  chromHMM_annotation = chromHMM_list, 
                                  genome_build = output_build,
                                  interact = params$interact)
  # save output 
  if(params$save_output){
    if(methods::is(samples_chromHMM,"plotly")){
      htmlwidgets::saveWidget(plotly::as_widget(samples_chromHMM), 
                            file = paste0(outfile_dir,"/samples_chromHMM.html"))
      unlink(paste0(outfile_dir,"/samples_chromHMM_files"), recursive = TRUE)
    }else{
      ggplot2::ggsave(filename = "samples_chromHMM.png", plot = samples_chromHMM, 
                      device = "png", path = outfile_dir)
      unlink("samples_chromHMM.png")
    }
  }
}else{
  samples_chromHMM <- "No plot"
}
samples_chromHMM
```

#### **Overlap**: Sample peaks in Reference peaks 

Percentage of Sample peaks found in Reference peaks 
(**Reference peakfile: `r names(reference_tidy)`**)

```{r, echo=FALSE, fig.width=9, warning=FALSE, message=FALSE, results='asis'}
if (params$chromHMM_plot){
  if (is.null(reference)==FALSE){
    # table of percentage overlap
    sample_in_ref_df <- overlap_percent(peaklist1 = peaklist_tidy,
                                        peaklist2 = reference_tidy,
                                        invert = FALSE)
    knitr::kable(sample_in_ref_df, format = "markdown")
  }
}
```

ChromHMM annotation of sample peaks found in reference peaks.   

```{r, echo=FALSE, fig.width=9, warning=FALSE, message=FALSE, results='asis', fig.height=fig_height}
if (params$chromHMM_plot){
  if (is.null(reference)==FALSE){
    # obtain overlapping peaks 
    sample_in_ref_list <- mapply(peaklist_tidy, FUN=function(file){
        IRanges::subsetByOverlaps(x = file, 
                                  ranges = reference_tidy[[1]])
    }) 
    # annotate overlapping peaks with chromHMM annotations
    sample_in_ref_chromHMM <- plot_chromHMM(peaklist = sample_in_ref_list,
                                          chromHMM_annotation = chromHMM_list,
                                          genome_build = output_build,
                                          interact = params$interact)
    if(params$interact){
      sample_in_ref_chromHMM_plot <- htmltools::tagList(plotly::as_widget(sample_in_ref_chromHMM))
      print(sample_in_ref_chromHMM_plot)
    }else{
      print(sample_in_ref_chromHMM)
    }
    # save output 
    if(params$save_output){
      if(params$interact){
        htmlwidgets::saveWidget(plotly::as_widget(sample_in_ref_chromHMM), 
                                file = paste0(outfile_dir,"/sample_in_ref_chromHMM.html"))
        unlink(paste0(outfile_dir,"/sample_in_ref_chromHMM_files"), recursive = TRUE)
      }else{
        ggplot2::ggsave(filename = "sample_in_ref_chromHMM.png", 
                        plot = sample_in_ref_chromHMM, device = "png", 
                        path = outfile_dir)
        unlink("sample_in_ref_chromHMM.png")
      }
    }
  }
}
```

#### **Overlap**: Reference peaks in Sample peaks 

Percentage of Reference peaks found in Sample peaks 
(**Reference peakfile: `r names(reference_tidy)`**)

```{r, echo=FALSE, fig.width=9, warning=FALSE, message=FALSE, results='asis'}
if (params$chromHMM_plot){
  if (is.null(reference)==FALSE){
    # table of percentage overlap
    ref_in_sample_df <- overlap_percent(peaklist1 = reference_tidy,
                                        peaklist2 = peaklist_tidy,
                                        invert = FALSE)
    knitr::kable(ref_in_sample_df, format = "markdown")
    
  }
}
```

ChromHMM annotation of reference peaks found in sample peaks.   

```{r, echo=FALSE, fig.width=9, warning=FALSE, message=FALSE, results='asis', fig.height=fig_height}
if (params$chromHMM_plot){
  if (!is.null(reference)){ 
      ref_in_sample_list <- mapply(peaklist_tidy, FUN = function(file){
          IRanges::subsetByOverlaps(x = reference_tidy[[1]], 
                                    ranges = file)
      }) 
    # annotate overlapping peaks with chromHMM annotations
    ref_in_sample_chromHMM <- plot_chromHMM(peaklist = ref_in_sample_list,
                                          chromHMM_annotation = chromHMM_list,
                                          genome_build = output_build,
                                          interact = params$interact)
    if(params$interact){
      ref_in_sample_chromHMM_plot <- htmltools::tagList(plotly::as_widget(ref_in_sample_chromHMM))
      print(ref_in_sample_chromHMM_plot)
    }else{
      print(ref_in_sample_chromHMM)
    }
    # save output 
    if(params$save_output){
      if(params$interact){
        htmlwidgets::saveWidget(plotly::as_widget(ref_in_sample_chromHMM), 
                                file = paste0(outfile_dir,"/ref_in_sample_chromHMM.html"))
        unlink(paste0(outfile_dir,"/ref_in_sample_chromHMM_files"), recursive = TRUE)
      }else{
        ggplot2::ggsave(filename = "ref_in_sample_chromHMM.png", 
                        plot = ref_in_sample_chromHMM, 
                        device = "png", path = outfile_dir)
        unlink("ref_in_sample_chromHMM.png")
      }
    }
  }
}
```

#### **Unique**: Sample peaks not in Reference peaks 

Percentage of sample peaks not found in reference peaks 
(**Reference peakfile: `r names(reference_tidy)`**)

```{r, echo=FALSE, fig.width=9, warning=FALSE, message=FALSE, results='asis'}
if (params$chromHMM_plot){
  if (is.null(reference)==FALSE){
    # table of percentage overlap
    sample_not_in_ref_df <- overlap_percent(peaklist1 = peaklist_tidy,
                                            peaklist2 = reference_tidy,
                                            invert = TRUE)
    knitr::kable(sample_not_in_ref_df, format = "markdown")
  }
}
```

ChromHMM annotation of sample peaks not found in reference peaks. 

```{r, echo=FALSE, fig.width=9, warning=FALSE, message=FALSE, results='asis', fig.height=fig_height}
if (params$chromHMM_plot){
  if (is.null(reference)==FALSE){
      sample_not_in_ref_list <- mapply(peaklist_tidy, FUN = function(file){
          IRanges::subsetByOverlaps(x = file, 
                                    ranges = reference_tidy[[1]], 
                                    invert = TRUE)
      }) 
      # annotate unique peaks with chromHMM annotations
      sample_not_in_ref_chromHMM<-plot_chromHMM(peaklist = sample_not_in_ref_list,
                                              chromHMM_annotation = chromHMM_list,
                                              genome_build = output_build,
                                              interact = params$interact)
      if(params$interact){
        sample_not_in_ref_chromHMM_plot <- htmltools::tagList(plotly::as_widget(sample_not_in_ref_chromHMM))
        print(sample_not_in_ref_chromHMM_plot)
      }else{
        print(sample_not_in_ref_chromHMM)
      }
      # save output 
      if(params$save_output){
        if(params$interact){
          htmlwidgets::saveWidget(plotly::as_widget(sample_not_in_ref_chromHMM), 
                                  file = paste0(outfile_dir,"/sample_not_in_ref_chromHMM.html"))
          unlink(paste0(outfile_dir,"/sample_not_in_ref_chromHMM_files"), 
                 recursive = TRUE)

        }else{
          ggplot2::ggsave(filename = "sample_not_in_ref_chromHMM.png", 
                          plot = sample_not_in_ref_chromHMM, device = "png", 
                          path = outfile_dir)
          unlink("sample_not_in_ref_chromHMM.png")
          }
      }
  }
}

```

#### **Unique**: Reference peaks not in Sample peaks 

Percentage of reference peaks not found in sample peaks 
(**Reference peakfile: `r names(reference_tidy)`**)

```{r, echo=FALSE, fig.width=9, warning=FALSE, message=FALSE, results='asis'}
if (params$chromHMM_plot){
  if (is.null(reference)==FALSE){
    # table of percentage overlap
    ref_not_in_sample_df <- overlap_percent(peaklist1 = reference_tidy,
                                            peaklist2 = peaklist_tidy,
                                            invert = TRUE)
    knitr::kable(ref_not_in_sample_df, format = "markdown")
  }
}
```

ChromHMM annotation of reference peaks not found in sample peaks. 

```{r, echo=FALSE, fig.width=9, warning=FALSE, message=FALSE, results='asis', fig.height=fig_height}
if (params$chromHMM_plot){
  if (is.null(reference)==FALSE){
      ref_not_in_sample_list <- mapply(peaklist_tidy, FUN = function(file){
          IRanges::subsetByOverlaps(x = reference_tidy[[1]], 
                                                       ranges = file, 
                                                       invert = TRUE)
      })
      # annotate unique peaks with chromHMM annotations
      ref_not_in_sample_chromHMM<-plot_chromHMM(peaklist = ref_not_in_sample_list,
                                              chromHMM_annotation = chromHMM_list,
                                              genome_build = output_build,
                                              interact = params$interact)
      if(params$interact){
        ref_not_in_sample_chromHMM_plot <- htmltools::tagList(plotly::as_widget(ref_not_in_sample_chromHMM))
        print(ref_not_in_sample_chromHMM_plot)
      }else{
        print(ref_not_in_sample_chromHMM)
      }
      # save output 
      if(params$save_output){
        if(params$interact){
          htmlwidgets::saveWidget(plotly::as_widget(ref_not_in_sample_chromHMM), 
                                  file = paste0(outfile_dir,"/ref_not_in_sample_chromHMM.html"))
          unlink(paste0(outfile_dir,"/ref_not_in_sample_chromHMM_files"), 
                 recursive = TRUE)
        }else{
          ggplot2::ggsave(filename = "ref_not_in_sample_chromHMM.png", 
                          plot = ref_not_in_sample_chromHMM, 
                          device = "png", path = outfile_dir)
          unlink("ref_not_in_sample_chromHMM.png")
        }
      }
  }
}
```

***

### 3.2 ChIPseeker 

EpiCompare uses `ChIPseeker::annotatePeak()` to annotate peaks with the nearest 
gene and genomic regions where the peak is located. The peaks are annotated 
with genes taken from human genome annotations (hg19 or hg38) provided by 
Bioconductor.

```{r, echo=FALSE, fig.width=9, warning=FALSE, message=FALSE}
# if set TRUE, generate chipseeker annotation plot 
if (params$chipseeker_plot){
  chipseeker_plot <- plot_ChIPseeker_annotation(peaklist = peaklist_tidy,
                                                annotation = txdb)
  print(chipseeker_plot)
  # save output 
  if(params$save_output){
    ggplot2::ggsave(filename = "chipseeker_annotation.png", 
                    plot = chipseeker_plot, device = "png", 
                    path = outfile_dir)
    unlink("chipseeker_annotation.png")
    }
}
```

***

### 3.3 Functional Enrichment Analysis {.tabset}

EpiCompare performs KEGG pathway and GO enrichment analysis using 
`clusterProfiler`. `ChIPseeker::annotatePeak()` is first used to assign peaks 
to nearest genes. Biological themes amongst the genes are identified using 
ontologies (KEGG and GO). The peaks are annotated with genes taken from 
annotations of human genome (hg19 or hg38) provided by Bioconductor.


```{r, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}
fig_height <- 10
if (params$enrichment_plot){
  enrichment_plots <- plot_enrichment(peaklist = peaklist_tidy,
                                      annotation = txdb)
  KEGG_plot <- enrichment_plots[[1]]
  GO_plot <- enrichment_plots[[2]]
  kegg_terms <- length(unique(KEGG_plot$data$Description))
  go_terms <- length(unique(GO_plot$data$Description))
  if(kegg_terms > 20 | go_terms > 20){
    maxN <- max(kegg_terms, go_terms)
    extraN <- maxN - 20
    fig_height <- fig_height + extraN*0.25
  }
}
```

***

#### KEGG

```{r,echo=FALSE,fig.width=10,fig.height=fig_height,warning=FALSE,message=FALSE}
if (params$enrichment_plot){
  print(KEGG_plot)
  # save output 
  if(params$save_output){
    ggplot2::ggsave(filename = "KEGG_analysis.png", plot = KEGG_plot, 
                    device = "png", path = outfile_dir)
    unlink("KEGG_analysis.png")
  }
}
```

***

#### GO 

```{r,echo=FALSE,fig.width=10,fig.height=fig_height,warning=FALSE,message=FALSE}
if (params$enrichment_plot){
  print(GO_plot)
  # save output 
  if(params$save_output){
    ggplot2::ggsave(filename = "GO_analysis.png", plot = GO_plot, 
                    device = "png", path = outfile_dir)
    unlink("GO_analysis.png")
  }
}

```

***

### 3.4 Peak Frequency around TSS 

This plots peaks that are mapping to transcriptional start sites (TSS). 
TSS regions are defined as the flanking sequence of the TSS sites. 
The frequency of peaks in downstream (-3000bp) and upstream (+3000bp) of 
TSS is plotted. Faint color line around the main frequency line represents 
the 95% confidence interval estimated by bootstrap method. 


```{r,echo=FALSE,fig.height=3,fig.width=10,warning=FALSE,message=FALSE}
if (params$tss_plot){
  tss_plot <- tss_plot(peaklist = peaklist_tidy,
                       annotation = txdb)
}
for (plot in tss_plot){
  print(plot)
}
```


### 4. Session Info

<details> 

```{r Session Info}
utils::sessionInfo()
```

</details>  

