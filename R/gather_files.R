#' Gather files
#'
#' Recursively find peak/picard files stored within subdirectories and import
#' them as a list of \link[GenomicRanges]{GRanges} objects.
#' 
#' For "peaks.stringent" files called with 
#' \href{https://github.com/FredHutch/SEACR}{SEACR}, column names will be
#' automatically added:
#' \itemize{
#' \item{total_signal : }{Total signal contained within denoted coordinates.}
#' \item{max_signal}{Maximum bedgraph signal attained at any base pair 
#'  within denoted coordinates.}
#' \item{max_signal_region}{ Region representing the farthest upstream 
#' and farthest downstream bases within the denoted coordinates 
#'  that are represented by the maximum bedgraph signal.}
#' }
#' 
#' @param dir Directory to search within.
#' @param type File type to search for. Options include:
#' \itemize{
#' \item{"<pattern>"}{Finds files matching an arbitrary regex pattern
#' specified by user.}
#' \item{"peaks.stringent"}{Finds files ending in "*.stringent.bed$"}
#' \item{"peaks.consensus"}{Finds files ending in "*.consensus.peaks.bed$"}
#' \item{"peaks.consensus.filtered"}{
#' Finds files ending in"*.consensus.peaks.filtered.awk.bed$"}
#' \item{"picard"}{Finds files ending in
#' "*.target.markdup.MarkDuplicates.metrics.txt$"}
#' }
#' @param nfcore_cutandrun Whether the files were generated by the
#' \href{https://nf-co.re/cutandrun}{nf-core/cutandrun} Nextflow pipeline.
#'  If \code{TRUE}, can use the standardised folder structure to
#'  automatically generate more descriptive file names with sample IDs.
#' @param return_paths Return only the file paths without actually reading them 
#' in as \link[GenomicRanges]{GRanges}. 
#' @inheritParams BiocParallel::MulticoreParam
#' @inheritDotParams bpplapply
#' @returns A named list of \link[GenomicRanges]{GRanges} objects.
#'
#' @export 
#' @importFrom methods is
#' @importFrom stats setNames
#' @importFrom stringr str_split
#' @importFrom GenomicRanges makeGRangesFromDataFrame
#' @importFrom rtracklayer import
#' @importFrom data.table fread 
#' @importFrom ChIPseeker readPeakFile
#' @examples
#' #### Make example files ####
#' save_paths <- EpiCompare::write_example_peaks()
#' dir <- unique(dirname(save_paths))
#' #### Gather/import files ####
#' peaks <- EpiCompare::gather_files(dir=dir, type="*.narrowPeaks.bed$")
gather_files <- function(dir,
                         type = "peaks.stringent",
                         nfcore_cutandrun = FALSE,
                         return_paths = FALSE,
                         workers = 1,
                         ...){
     
  #### Parse type arg ####
  type_key <- c(
    "peaks.stringent"="*.stringent.bed$",
    "peaks.consensus"="*.consensus.peaks.bed$",
    "peaks.consensus.filtered"="*.consensus.peaks.filtered.awk.bed$",
    "peaks.pooled"="pooledPeak",
    "peaks.narrow"="narrowPeak",
    "peaks.broad"="broadPeak",
    "picard"= "*.target.markdup.MarkDuplicates.metrics.txt$"
  )
  pattern <- if(type %in% names(type_key)) type_key[tolower(type)] else type
  if(is.na(pattern)){
    stop("type must be at least one of:\n",
         paste("-",c(names(type_key),"<regex query>"), collapse = "\n"))
  }
  #### Search for files recursively ####
  message("Searching for ",type," files...")
  paths <- list.files(path = dir,
                      pattern = paste(unname(pattern), collapse = "|"),
                      recursive = TRUE,
                      full.names = TRUE)
  #### Remove any R scripts ####
  paths <- grep("\\.R", paths, value = TRUE, invert = TRUE) 
  #### Omit duplicate files ####
  ## nfcore creates duplicates of same peak files 
  ## in different subfolders: "04_reporting" and "04_called_peaks".
  ## Omit one of these subfolders.
  if(isTRUE(nfcore_cutandrun)){
      paths <- paths[!grepl("04_reporting",paths)]
  }
  #### Report files found ####
  if(length(paths)==0) {
      msg <- "0 matching files identified. Returning NULL."
      message(msg)
      return(NULL)
  }
  message(formatC(length(paths),big.mark = ","),
          " matching files identified.")
  #### Construct names ####
  list_names <- gather_files_names(paths=paths,
                                   type=type,
                                   nfcore_cutandrun=nfcore_cutandrun)
  if(isTRUE(return_paths)){
      return(stats::setNames(paths,list_names))
  }
  #### Import files ####
  message("Importing files.")  
  files <- bpplapply(X = paths, 
                     workers = workers,
                     FUN = function(x){
    # message_parallel(x,"\n")
    if(startsWith(type,"peaks")){
      dat <- ChIPseeker::readPeakFile(x, as = "GRanges")
      if(type=="peaks.stringent" && 
         (ncol(GenomicRanges::mcols(dat))==3)){
          ## Colnames are not included in SEACR output,
          ## but can be found in the SEACR documentation.
          colnames(GenomicRanges::mcols(dat))  <- c("total_signal",
                                                    "max_signal",
                                                    "max_signal_region")
      }
    } else if(type=="picard"){
      dat <- data.table::fread(x,
                               skip = "LIBRARY",
                               fill = TRUE,
                               nrows = 1)
    } else if(grepl("narrowPeak",x,ignore.case = TRUE)){
      dat <- rtracklayer::import(x, format = "narrowPeak")
    } else {
      dat <- data.table::fread(x)
    }
    #### Ensure GRanges format ####
    if(!methods::is(dat,"GRanges")) {
      ## Try to convert to GRanges, but if it fails,
      ## just return the data.table
      dat <- tryCatch({
        GenomicRanges::makeGRangesFromDataFrame(
          df = dat,
          keep.extra.columns = TRUE)
      }, error = function(e) dat)
    }
    return(dat)
  }, ...) |> `names<-`(list_names)
  #### Report ####
  message(length(files)," files retrieved.")
  return(files)
}

